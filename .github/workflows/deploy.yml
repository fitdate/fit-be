name: Deploy Backend Application

on:
  push:
    branches: [main, develop]
    paths:
      - '**.ts'
      - 'package*.json'
      - 'tsconfig*.json'
      - '.env.example'
      - 'nest-cli.json'
      - '.github/workflows/**'
      - 'Dockerfile'
      - 'nginx-config/**'
      - '!frontend/**'

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install SSH key
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Configure SSH and Create .env
        run: |
          mkdir -p ~/.ssh
          echo "StrictHostKeyChecking no" >> ~/.ssh/config
          echo "ServerAliveInterval 30" >> ~/.ssh/config
          echo "${{ secrets.ENV_FILE }}" > .env

      - name: Build Docker image
        run: |
          docker build -t fit-be:$GITHUB_SHA .
          docker tag fit-be:$GITHUB_SHA ${{ secrets.DOCKER_USERNAME }}/fit-be:$GITHUB_SHA
          docker tag fit-be:$GITHUB_SHA ${{ secrets.DOCKER_USERNAME }}/fit-be:latest
          docker system prune -f

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Push Docker image
        run: |
          docker push ${{ secrets.DOCKER_USERNAME }}/fit-be:$GITHUB_SHA
          docker push ${{ secrets.DOCKER_USERNAME }}/fit-be:latest

      - name: Check Database Server Status
        run: |
          echo "Checking database server status..."
          ssh ${{ secrets.USERNAME }}@${{ secrets.DB_HOST }} "systemctl status postgresql || echo 'PostgreSQL service not found'" || {
            echo "‚ùå Failed to check database server status"
            exit 1
          }
          echo "‚úÖ Database server status check completed"

      - name: Test Database Connection
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: fit
        run: |
          if [ -z "$DB_HOST" ] || [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ]; then
            echo "‚ùå DB Í¥ÄÎ†® ÌôòÍ≤Ω Î≥ÄÏàòÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§."
            exit 1
          fi

          echo "üîç Database connection test configuration:"
          echo "Host: $DB_HOST"
          echo "Database: $DB_NAME"
          echo "Username: $DB_USER"

          echo "üîÑ Creating database if not exists..."
          ssh ${{ secrets.USERNAME }}@$DB_HOST "PGPASSWORD='$DB_PASSWORD' psql -U $DB_USER -h $DB_HOST -p 5432 -c 'CREATE DATABASE \"$DB_NAME\"' || true"

          echo "üîÑ Testing database connection..."
          ssh ${{ secrets.USERNAME }}@$DB_HOST "PGPASSWORD='$DB_PASSWORD' psql -U $DB_USER -d $DB_NAME -h $DB_HOST -p 5432 -c 'SELECT 1'" || {
            echo "‚ùå Database connection test failed"
            exit 1
          }
          echo "‚úÖ Database connection test successful"

      - name: Reset DB schema
        run: |
          echo "üóëÔ∏è Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà Ï¥àÍ∏∞Ìôî Ï§ë..."
          ssh ${{ secrets.USERNAME }}@${{ secrets.DB_HOST }} "
            export PGPASSWORD='${{ secrets.DB_PASSWORD }}'
            psql -U ${{ secrets.DB_USER }} -d fit -h ${{ secrets.DB_HOST }} -p 5432 << EOF
              DROP SCHEMA IF EXISTS public CASCADE;
              CREATE SCHEMA public;
              GRANT ALL ON SCHEMA public TO ${{ secrets.DB_USER }};
              GRANT ALL ON SCHEMA public TO public;
              ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO ${{ secrets.DB_USER }};
              ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO ${{ secrets.DB_USER }};
              GRANT ALL ON ALL TABLES IN SCHEMA public TO ${{ secrets.DB_USER }};
              GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO ${{ secrets.DB_USER }};
              
              -- chat_room_users ÌÖåÏù¥Î∏î Í¥ÄÎ†® Ï†úÏïΩ Ï°∞Í±¥ Í∞ïÏ†ú ÏÇ≠Ï†ú
              DROP TABLE IF EXISTS chat_room_users CASCADE;
            EOF
          " || {
            echo "‚ùå Failed to reset database schema"
            exit 1
          }
          echo "‚úÖ Database schema reset successful"

      - name: Deploy to EC2
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          USERNAME: ${{ secrets.USERNAME }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          BLUE_PORT: 3000
          GREEN_PORT: 3001
        run: |
          ssh -o ConnectTimeout=10 $USERNAME@$DB_HOST "echo 'SSH connection test successful'"

          ssh $USERNAME@$DB_HOST "mkdir -p ~/nginx-config && chmod 755 ~/nginx-config"
          ssh $USERNAME@$DB_HOST "sudo mkdir -p /etc/nginx/sites-available"
          scp nginx-config/fit-blue.conf $USERNAME@$DB_HOST:~/fit-blue.conf
          scp nginx-config/fit-green.conf $USERNAME@$DB_HOST:~/fit-green.conf
          ssh $USERNAME@$DB_HOST "sudo mv ~/fit-blue.conf /etc/nginx/sites-available/ && sudo mv ~/fit-green.conf /etc/nginx/sites-available/"
          ssh $USERNAME@$DB_HOST "sudo mkdir -p /etc/nginx/sites-enabled"

          CURRENT_PORT=$(ssh $USERNAME@$DB_HOST "curl -s localhost/port || echo $BLUE_PORT")
          if [ \"$CURRENT_PORT\" = \"$BLUE_PORT\" ]; then
            NEW_PORT=$GREEN_PORT
            NEW_ENV="green"
            CURRENT_ENV="blue"
          else
            NEW_PORT=$BLUE_PORT
            NEW_ENV="blue"
            CURRENT_ENV="green"
          fi

          scp .env $USERNAME@$DB_HOST:~/

          ssh $USERNAME@$DB_HOST "
            set -e
            echo 'üßπ Í∏∞Ï°¥ ÌîÑÎ°úÏÑ∏Ïä§ Ï†ïÎ¶¨ Ï§ë...'
            sudo kill -9 \$(sudo lsof -t -i:3000) 2>/dev/null || true
            sudo kill -9 \$(sudo lsof -t -i:3001) 2>/dev/null || true
            sudo docker stop fit-blue fit-green 2>/dev/null || true
            sudo docker rm fit-blue fit-green 2>/dev/null || true

            echo 'üßπ ÎèÑÏª§ Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨ Ï§ë...'
            sudo docker system prune -a --volumes -f

            echo 'üê≥ Docker Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìú Ï§ë...'
            sudo docker pull $DOCKER_USERNAME/fit-be:$GITHUB_SHA

            echo 'üöÄ ÏÉà Ïª®ÌÖåÏù¥ÎÑà ÏãúÏûë Ï§ë...'
            sudo docker run -d --name fit-$NEW_ENV \
              -p $NEW_PORT:3000 \
              -v ~/\.env:/usr/src/app/.env \
              -e APP_PORT=$NEW_PORT \
              --log-driver json-file \
              --log-opt max-size=10m \
              --log-opt max-file=3 \
              --restart unless-stopped \
              $DOCKER_USERNAME/fit-be:$GITHUB_SHA

            echo 'üîå ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ Ï§ë...'
            sudo docker network connect fit-network fit-$NEW_ENV || true
            sudo docker network connect redis-network fit-$NEW_ENV || true

            echo 'üîç Ïª®ÌÖåÏù¥ÎÑà ÏÉÅÌÉú ÌôïÏù∏ Ï§ë...'
            if [ \"\$(sudo docker inspect -f '{{.State.Status}}' fit-$NEW_ENV)\" != \"running\" ]; then
              echo '‚ùå Ïª®ÌÖåÏù¥ÎÑà Ïã§Ìñâ Ïã§Ìå®'
              sudo docker logs fit-$NEW_ENV
              exit 1
            fi

            echo 'üîÑ Nginx ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë...'
            sudo ln -sf /etc/nginx/sites-available/fit-$NEW_ENV.conf /etc/nginx/sites-enabled/
            sudo nginx -t && sudo systemctl reload nginx

            echo 'üè• Ìó¨Ïä§ Ï≤¥ÌÅ¨ Ï§ë...'
            for i in {1..3}; do
              if curl -s -f http://localhost:$NEW_PORT/health | grep -q 'ok'; then
                sudo docker stop fit-$CURRENT_ENV 2>/dev/null || true
                sudo docker rm fit-$CURRENT_ENV 2>/dev/null || true
                sudo rm -f /etc/nginx/sites-enabled/fit-$CURRENT_ENV.conf
                sudo nginx -t && sudo systemctl reload nginx
                echo '‚úÖ Î∞∞Ìè¨ ÏÑ±Í≥µ'
                exit 0
              fi
              sleep 5
            done

            echo '‚ùå Ìó¨Ïä§ Ï≤¥ÌÅ¨ Ïã§Ìå®'
            sudo docker logs fit-$NEW_ENV
            sudo docker stop fit-$NEW_ENV
            sudo docker rm fit-$NEW_ENV
            exit 1
          "
